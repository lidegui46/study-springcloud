1、NIO

    Buffer:
            是一块连续的内存块。
            是 NIO 数据读或写的中转地。
    Channel:
            数据的源头或者数据的目的地
            用于向 buffer 提供数据或者读取 buffer 数据 ,buffer 对象的唯一接口。
            异步 I/O 支持
       Buffer作为IO流中数据的缓冲区，而Channel则作为socket的IO流与Buffer的传输通道。客户端socket与服务端socket之间的IO传输不直接把数据交给CPU使用，
    而是先经过Channel通道把数据保存到Buffer，然后CPU直接从Buffer区读写数据，一次可以读写更多的内容。
       使用Buffer提高IO效率的原因（这里与IO流里面的BufferedXXStream、BufferedReader、BufferedWriter提高性能的原理一样）：IO的耗时
       主要花在数据传输的路上，普通的IO是一个字节一个字节地传输，
    而采用了Buffer的话，通过Buffer封装的方法（比如一次读一行，则以行为单位传输而不是一个字节一次进行传输）就可以实现“一大块字节”的传输。
    比如：IO就是送快递，普通IO是一个快递跑一趟，采用了Buffer的IO就是一车跑一趟。很明显，buffer效率更高，花在传输路上
    的时间大大缩短。

2、事件分享器

    Reactor：同步
        - 应用程序在事件分离器注册 读就绪事件 和 读就绪事件处理器
        - 事件分离器等待读就绪事件发生
        - 读就绪事件发生，激活事件分离器，分离器调用 读就绪事件处理器（即：可以进行读操作了，开始读）
        - 读事件处理器开始进行读操作，把读到的数据提供给程序使用
    Proactor：异步
       - 应用程序在事件分离器注册 读完成事件 和 读完成事件处理器，并向操作系统发出异步读请求    
       - 事件分离器等待操作系统完成读取    
       - 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成    
       - 事件分离器监听到 读完成事件 后，激活 读完成事件的处理器    
       - 读完成事件处理器 处理用户自定义缓冲区中的数据给应用程序使用
       
    对比:
        同步和异步的区别就在于 读 操作由谁完成：同步的Reactor是指程序发出读请求后，由分离器监听到可以进行读操作时（需要获得读操作条件）通知事件处理器进行读操作，
        异步的Proactor是指程序发出读请求后，操作系统立刻异步地进行读操作了，读完之后在通知分离器，分离器激活处理器直接取用已读到的数据。
    
2、IO对比

    2.1、BIO（Blocking IO）
        同步阻塞IO
            操作系统允许的线程数量是有限的，多个socket申请与服务端建立连接时，服务端不能提供相应数量的处理线程，未分配到处理线程的连接就会阻塞等待或被拒绝.
            N个客户端发起socket申请与服务端建立连接时，服务端会建立对应N个处理线程（1：1）；
        可靠性：差
        吞吐量：低
       
    2.2、NIO（New IO）
        同步非阻塞IO
        核心
            buffer 缓冲区
                负责写入 或 读出 的数据
                通过buffer可以提高数据通信的性能，比如：设置buffer 缓冲区大小为100时，每次写或读可操作100字节长度的数据，大大提高访问的性能；
            channel 管道
                客户端向服务端 或 服务端向客户端 同时进行读和写数据操作（channel是双向操作的，stream是单向操作）
                buffer通过channel进行数据传输
            selector 多路复用器
                无最大连接数的限制
        可靠性：差
        吞吐量：高
    
    2.3、AIO（Async IO）
        异步非阻塞IO
        连接注册读写事件和回调函数
        数据的读与写方法是异步
        主动通知程序 
        吞吐量：高
    
    2.4、伪AIO   
        同步阻塞IO
        客户端发起socket请求时，服务端通过Task运行在线程池里，由于线程池可以设置最大线程数，因此客户端超过线程池最大的线程数时会导致线程池阻塞; 
        
    
    
4、JDK 原生 NIO 存在Bug
    
    